name: Docker Image CI

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  golangci:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-go@v3
        with:
          go-version: 1.17
      - uses: actions/checkout@v3
      - name: golangci-lint
        uses: golangci/golangci-lint-action@v3
        with:
          # Optional: version of golangci-lint to use in form of v1.2 or v1.2.3 or `latest` to use the latest version
          version: v1.29
          # Optional: working directory, useful for monorepos
          working-directory: docker-gs-ping

  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
    - name: Check out code
      uses: actions/checkout@v3
    - name: test the Docker image
      run: |
        cd ./docker-gs-ping
        docker build -t docker-gs-ping:latest .
        go test -v main_test.go

  docker: 
    name: Docker  
    runs-on: ubuntu-latest
    needs: [golangci, test]
    steps:
      - name: Check out code
        uses: actions/checkout@v3
      - name: Docker login
        env:
          DOCKER_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          docker login -u $DOCKER_USER -p $DOCKER_PASSWORD
      - name: build docker image
        run: |
          cd ./docker-gs-ping/
          docker build -t docker-gs-ping -f Dockerfile .
          docker tag docker-gs-ping:latest ${{secrets.DOCKERHUB_USERNAME}}/devops:latest
      - name: docker push
        run: docker push ${{secrets.DOCKERHUB_USERNAME}}/devops
        
  terraform-init-plan:
    name: 'Terraform plan'
    runs-on: ubuntu-latest
    needs: docker

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v3

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: |
        cd ./tf/
        terraform init -input=false
        terraform plan 

  terraform-apply:
    name: 'Terraform apply'
    runs-on: ubuntu-latest
    needs: terraform-init-plan

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
      # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v3

      # On push to "master", build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      # if: github.ref == 'refs/heads/"master"' && github.event_name == 'push'
      run: |
        cd ./tf/
        terraform init -input=false
        terraform apply -auto-approve 

  ansible:
    name: ansible
    runs-on: ubuntu-latest
    needs: terraform-apply
    steps:
    - name: Checkout
      uses: actions/checkout@v3    
    - name: install python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'  
    - name: install boto3
      run: |
          pip install boto3 requests pyjwt  
    - name: Create dir
      run: |
          mkdir -p ~/.ssh/
      shell: bash          
    - name: Create SSH key
      run: |
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/private.key 
      shell: bash  
      env:
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}                 
      # Checkout the repository to the GitHub Actions runner
    - name: chmod SSH key
      run: |
          sudo chmod 600 ~/.ssh//private.key
      shell: bash
      env:
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }} 

    - name: Play Ansible Playbook
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: |
        cd ./ansible/
        export ANSIBLE_HOST_KEY_CHECKING=False
        ansible-playbook playbook.yml -i aws_ec2.yml --key-file ~/.ssh/private.key      
 
    # - name: run command
    #   run: export ANSIBLE_HOST_KEY_CHECKING=False
    # - name: Run Ansible playbook
    #   env:
    #     AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #   uses: DmitryYankov/test@2.6.1
    #   with:
    #       playbook: playbook.yml # path to your Ansible playbook
    #       directory: ./ansible/
    #       key: ${{secrets.SSH_PRIVATE_KEY}} # the ssh private key for ansible to use to connect to the servers, stored as "ansible_ssh_private_key" in the GitHub secrets
    #       inventory: aws_ec2.yml # the ansible inventory to use, stored as "ansible_inventory" in the GitHub secrets

      
